
2022/ 06/ 06 컴포넌트 스캔과 자동 의존관계 설정


 * @Controller 를 통해서 외부 요청을 받고
 * @Service 에서 비즈니스 로직을 만들고
 * @Repository 에서 데이터를 저장을 한다.

스프링 빈을 등록하는 2가지 방법
1. 컴포넌트 스캔과 자동 의존관계 설정
2. 자바 코드로 직접 스프링 빈 등록하기


@Component 어노테이션이 있으면 스프링 빈으로 자동 등록된다.

@Component를 포함하는 다음 어노테이션도 스프링 빈으로 자동 등록된다.
    @Controller
    @Service
    @Repository

@Controller 컨트롤러가 스프링 빈으로 자동 등록된 이유도 컴포넌트 스캔 때문임.

@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Component
public @interface Controller {

	/**
	 * The value may indicate a suggestion for a logical component name,
	 * to be turned into a Spring bean in case of an autodetected component.
	 * @return the suggested component name, if any (or empty String otherwise)
	 */
	@AliasFor(annotation = Component.class)
	String value() default "";

}

스프링은 스프링 컨테이너에 스프링 빈을 등록할때, 기본으로 싱글톤으로 등록한다( 유일하게 하나만 등록해서 공유)
따라서 같은 스프링 빈이면 모두 같은 인스턴스다.
설정으로 싱글톤이 아니게 설정할 수 있지만.
특별한 경우를 제외하면 대부분 싱글톤을 사용한다.



2022/ 06/ 06 자바 코드로 직접 스프링 빈 등록하기
1. 과거에는 xml로 Bean을 설정하는 방식도 있었지만 최근에는 잘 사용하지 않음
2. Di에는 필드 주입, 생성자 주입, setter 주입 이렇게 3가지 방법이 있다.
    의존관계가 어플리케이션 실행중에 동적으로 변하는 경우는 거의 없으므로 생성자 주입을 권장함.

    가. 생성자 주입
        private final MemberService memberService

        @Autowired
        public MemberController(MemberService memberService){
            this.memberService = memberService;
        }

    나. 필드 주입
        @Autowired
        private MemberService memberService;

    다. setter 주입
        누군가가 컨트롤러를 호출했을때 setter가 public으로 열려있어야하는데
        보통 어플리케이션이 구동중에는 service가 바뀔일이 잘 없지만
        public으로 열려있게 되면 service가 잘못 바뀔수가 있다.

        @Autowired
        public void setMemberService(MemberService memberService){
            this.memberService = memberService;
        }

3. 실무에서는 주로 정형화된 컨트롤러, 서비스, 리포지토리 같은 코드는 컴포넌트 스캔을 사용한다.
    그리고 정형화 되지 않거나, 상황에 따라 구현 클래스를 변경해야 하면 설정을 통해 스프링 빈으로 등록한다.


4. @Autowired를 통한 DI는 스프링이 관리하는 객체에서만 동작한다.
    스프링 빈으로 등록하지 않고 내가 직접 생성한 객체에서는 동작하지 않는다.

